/*
 * author: Dominik Leichtle, dominik.leichtle@web.de
 * institute: Technische Universiteit Eindhoven
 * date: Wed, 2017-12-13
 */

#include "sig.h"

#ifdef NIST_API
#include "rng.h"
#endif

/* -------------------------------------------------- */
/* Computation of Hamming weight and parity */

// Use a lookup table, specifying the Hamming weights of words of one byte.
const size_t Hamming_weight[256] =
{
	0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
	1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
	2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
	3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 
	4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
};

/* -------------------------------------------------- */
/* Randomness */

#ifndef NIST_API
// The size of the seed for the randomness pool (in bytes).
size_t rand_seedByteLen = 256/8;
// The Keccak hash instance used to expand the seed.
Keccak_HashInstance rand_KeccakHashInstance;

// Initialize the randomness pool.
int rand_init()
{
	// read some random data from /dev/urandom
	unsigned char* rand_seed = calloc(rand_seedByteLen, sizeof(unsigned char));
	int randData = open("/dev/urandom", O_RDONLY);
	if (randData < 0) {
		free(rand_seed);
		return -1;
	} else {
		ssize_t res = read(randData, rand_seed, rand_seedByteLen);
		if (res < 0) {
			free(rand_seed);
			return -1;
		}
		close(randData);
	}

	// init the Keccak hash instance
	if (Keccak_HashInitialize_SHAKE256(&rand_KeccakHashInstance) != SUCCESS) {
		// the initialization was unsuccessful
		free(rand_seed);
		return -1;
	}
	// feed the random seed
	if (Keccak_HashUpdate(&rand_KeccakHashInstance, rand_seed, rand_seedByteLen * 8) != SUCCESS) { // specify the seed length in bits
		// the updating was unsuccessful
		free(rand_seed);
		return -1;
	}
	// finalize the Keccak hash instance, prepare for squeezing the digest
	if (Keccak_HashFinal(&rand_KeccakHashInstance, NULL) != SUCCESS) { // don't extract the digest here, squeeze later
		// the finalization was unsuccessful
		free(rand_seed);
		return -1;
	}

	free(rand_seed);

	// successful execution
	return 0;
}

// Access the randomness pool.
int get_randomness(unsigned char* buf, size_t bufByteLen)
{
	// squeeze the Keccak hash instance to get the SHAKE-256 generated bytes
	if (Keccak_HashSqueeze(&rand_KeccakHashInstance, buf, bufByteLen * 8) != SUCCESS) { // specify digest length in bits
		// something went wrong in the evaluation of the hash function
		return -1;
	}

	// successful execution
	return 0;
}
#else // NIST_API
int get_randomness(unsigned char* buf, size_t bufByteLen)
{
	if (randombytes(buf, bufByteLen) == RNG_SUCCESS) {
		return 0;
	} else {
		return -1;
	}
}
#endif // NIST_API

// Returns a uniform integer in the set {0,...,bound-1}.
int get_rand_uint(size_t bound, size_t* res, Keccak_HashInstance* hashInstance)
{
	// catch special cases
	if (bound == 0) {
		return -1;
	}
	if (bound == 1) {
		*res = 0;
		return 0;
	}

	// the number of bits necessary to store a number in {0,...,bound-1}
	size_t no_bits = (size_t)(ceil(log2((double)bound)));
	// the number of necessary bytes
	size_t no_bytes = (no_bits+7)/8;
	unsigned char* buf = calloc(no_bytes, sizeof(unsigned char));
	// try to generate a number in {0,...,bound-1}
	// - randomly generate a number in {0,...,2^no_bits-1}
	// - if >= bound, the number needs to be discarded to ensure a uniform distribution
	// at least half of the generated numbers are < bound,
	// thus, the expected number of iterations of the following loop is <= 2
	while (true) {
		// get randomness from the hash instance
		if (Keccak_HashSqueeze(hashInstance, buf, no_bytes*8) != SUCCESS) {
			// something went wrong
			free(buf);
			return -1;
		}
		// transform the relevant bits to size_t
		size_t temp = 0;
		for (int i=0; i<no_bytes-1; i++) { // all bytes in the buffer except for the last
			temp += ((size_t)buf[i])<<(i*8);
		}
		// mask the last byte to extract the valid bits
		temp += (((size_t)(buf[no_bytes-1])) & ((1<<(((no_bits+7)%8)+1))-1)) << ((no_bytes-1)*8);
		// check if temp matches the bound
		if (temp < bound) {
			// success, exit loop
			*res = temp;
			break;
		}
	}

	free(buf);

	// successful execution
	return 0;
}

/* -------------------------------------------------- */
/* Application of a permutation to a vector of n bits */

// In-place binary MSD radix sort.
// begin points to the first element, end points to the element behind the list
// no_bit: the bit to start with (counting no_bit=1 as the most significant bit)
// returns true in case of a collision (ignoring the last bit), false otherwise
#ifdef PERMUTATIONS_USE_64BIT
bool radix_sort_aux(uint64_t* begin, uint64_t* end, size_t no_bit)
#else
bool radix_sort_aux(uint32_t* begin, uint32_t* end, size_t no_bit)
#endif
{
	// break recursion
	if ((end - begin) <= 1) {
		// at most one element left, therefore no collision
		return false;
	}
#ifdef PERMUTATIONS_USE_64BIT
	if (no_bit >= 64) {
#else
	if (no_bit >= 32) {
#endif
		// more than one element left, and already all bits except for the last compared
		// hence, we found a collision
		return true;
	}

	// divide into buckets
#ifdef PERMUTATIONS_USE_64BIT
	uint64_t mask = ((uint64_t)1)<<(64-no_bit);
	uint64_t* end_bucket0 = begin;
	uint64_t* begin_bucket1 = end;
	uint64_t temp;
#else
	uint32_t mask = ((uint32_t)1)<<(32-no_bit);
	uint32_t* end_bucket0 = begin;
	uint32_t* begin_bucket1 = end;
	uint32_t temp;
#endif
	while (end_bucket0 != begin_bucket1) {
		if (((*end_bucket0) & mask) == 0) {
			end_bucket0++;
		} else {
			begin_bucket1--;
			temp = (*end_bucket0);
			(*end_bucket0) = (*begin_bucket1);
			(*begin_bucket1) = temp;
		}
	}

	// sort the buckets (considering the next less significant bit)
	bool collision = false;
	collision = collision || radix_sort_aux(begin, end_bucket0, no_bit+1);
	collision = collision || radix_sort_aux(begin_bucket1, end, no_bit+1);
	return collision;
}

// This function encapsulates the radix sort auxiliary function.
// data points to the beginning of the list to sort
// len specifies the number of elements in the list
// returns true in case of a collision (ignoring the last bit), false otherwise
#ifdef PERMUTATIONS_USE_64BIT
bool radix_sort(uint64_t* data, size_t len)
#else
bool radix_sort(uint32_t* data, size_t len)
#endif
{
	return radix_sort_aux(data, data+len, 1);
}

// Applies a permutatation to a word on bit-level.
// seedPerm determines the permutation
// word has an assumed length of p->n bits
// returns 0 if successful and -1 otherwise
int apply_permutation(const Params* p, const unsigned char* seedPerm, unsigned char* word)
{
	// detect failures evaluating SHAKE
	bool fail = false;

#ifdef PERMUTATIONS_USE_64BIT
	uint64_t* temp;
#else
	uint32_t* temp;
#endif
	// try to apply the permutation
	// a failure occurs in the (unlikely) case of a collision in the sorting
	// in case of a collision, we need to start over and try again
	size_t try = 1;
	while (true) {
		// fill a list of p->n numbers by expanding the seed
#ifdef PERMUTATIONS_USE_64BIT
		temp = (uint64_t*) malloc(try * p->n * sizeof(uint64_t));
		if (SHAKE256((unsigned char*) temp, try * p->n * sizeof(uint64_t), seedPerm, p->seedPermByteLen) != 0){ fail = true; };
#else
		temp = (uint32_t*) malloc(try * p->n * sizeof(uint32_t));
		if (SHAKE256((unsigned char*) temp, try * p->n * sizeof(uint32_t), seedPerm, p->seedPermByteLen) != 0){ fail = true; };
#endif

		// set least significant bits of all numbers in temp
		for (int i=0; i<p->n; i++) {
#ifdef PERMUTATIONS_USE_64BIT
			uint64_t wordBit = ( word[i/8] & (1<<(i%8)) )>>(i%8);
			temp[(try-1)*p->n + i] = (temp[(try-1)*p->n + i] & 0xFFFFFFFFFFFFFFFE) | (wordBit & 0x0000000000000001);
#else
			uint32_t wordBit = ( word[i/8] & (1<<(i%8)) )>>(i%8);
			temp[(try-1)*p->n + i] = (temp[(try-1)*p->n + i] & 0xFFFFFFFE) | (wordBit & 0x00000001);
#endif
		}

		// sort numbers
		bool collision = radix_sort(temp + (try-1)*p->n, p->n);

		if (collision) {
			free(temp);
			try++;
			// we need to start over and try again
		} else {
			break;
		}
	}

	// read least significant bits as one word
	for (int i=0; i<p->n; i++) {
#ifdef PERMUTATIONS_USE_64BIT
		word[i/8] = (word[i/8] & (~(1<<(i%8)))) | ((temp[(try-1)*p->n + i] & 0x0000000000000001)<<(i%8));
#else
		word[i/8] = (word[i/8] & (~(1<<(i%8)))) | ((temp[(try-1)*p->n + i] & 0x00000001)<<(i%8));
#endif
	}

	// clean up
	free(temp);

	// successful execution?
	if (fail) {
		return -1;
	} else {
		return 0;
	}
}

/* -------------------------------------------------- */
/* Arithmetic in F_2 */

// Performs the multiplication H*x on bit-level (in F_2) and write the result to res.
// note: in res there must be space for at least p->r_in_bytes bytes
void mult_H(const Params* p, unsigned char** H, const unsigned char* x, unsigned char* res)
{
	// set res to zero
	for (int i=0; i<p->r_in_bytes; i++) {
		res[i] = 0;
	}
	// compute matrix-vector multiplication H*x = res
	for (int i=0; i<p->r; i++) { // every iteration computes one bit of the result
		// perform AND and compute parity
		unsigned char b = 0;
		for (int j=0; j<p->n_in_bytes; j++) {
			b ^= Hamming_weight[x[j] & H[i][j]];
		}
		b &= 1; // get only the parity
		res[i/8] = (res[i/8] & (~(1<<(i%8)))) | (b<<(i%8)); // insert bit into the result
	}
}

// Performs the addition x+y on bit-level (in F_2) and writes the result to res.
// note: in res there must be space for at least p->n_in_bytes bytes
void add_in_F2n(const Params* p, const unsigned char* x, const unsigned char* y, unsigned char* res)
{
	// add (wrap in F_2)
	for (int i=0; i<p->n_in_bytes; i++) {
		res[i] = x[i] ^ y[i];
	}
}

// Performs the addition x+y on bit-level (in F_2) and writes the result to res.
// note: in res there must be space for at least p->r_in_bytes bytes
void add_in_F2r(const Params* p, const unsigned char* x, const unsigned char* y, unsigned char* res)
{
	// add (wrap in F_2)
	for (int i=0; i<p->r_in_bytes; i++) {
		res[i] = x[i] ^ y[i];
	}
}

/* -------------------------------------------------- */
/* Parameters */

// Initialize the parameter set given by *p.
int init_params(Params* p, size_t n, size_t r, size_t w, size_t t, size_t seedByteLen, size_t sigByteLen, size_t chHashByteLen)
{
	// set the parameters
	p->n = n;
	p->n_in_bytes = (p->n+7)/8;
	p->r = r;
	p->r_in_bytes = (p->r+7)/8;
	p->w = w;
	p->t = t;
	p->seedSkByteLen = seedByteLen;
	p->seedHByteLen = seedByteLen;
	p->commByteLen = seedByteLen;
	p->seedYByteLen = seedByteLen;
	p->seedPermByteLen = seedByteLen;
	p->coinsCommByteLen = seedByteLen;
	p->sigByteLen = sigByteLen;
	p->chHashByteLen = chHashByteLen;
	p->skByteLen = p->seedSkByteLen;
	p->pkByteLen = p->seedHByteLen + p->r_in_bytes;

	// successful execution
	return 0;
}

// Initializes a parameter set for 64-bit post-quantum security.
int init_params_64pq(Params* p)
{
	return init_params(p, 1488, 744, 124, 219, 128/8, 72957, 128/8);
}

// Initializes a parameter set for 128-bit classical security.
int init_params_128cl(Params* p)
{
	return init_params(p, 1664, 832, 143, 219, 256/8, 92449, 256/8);
}

// Initializes a parameter set for 96-bit post-quantum security.
int init_params_96pq(Params* p)
{
	return init_params(p, 2222, 1111, 185, 329, 192/8, 156483, 192/8);
}

// Initializes a parameter set for 192-bit classical security.
int init_params_192cl(Params* p)
{
	return init_params(p, 2500, 1250, 215, 329, 384/8, 200943, 384/8);
}

// Initializes a parameter set for 128-bit post-quantum security.
int init_params_128pq(Params* p)
{
	return init_params(p, 2966, 1483, 247, 438, 256/8, 270314, 256/8);
}

// Initializes a parameter set for 256-bit classical security.
int init_params_256cl(Params* p)
{
	return init_params(p, 3326, 1663, 286, 438, 512/8, 348109, 512/8);
}

/* -------------------------------------------------- */

// Generates a key pair.
int generate_keypair(const Params* p, unsigned char* sk, unsigned char* pk)
{
	// detect failures, e.g. generating randomness or evaluating SHAKE
	bool fail = false;

	// generate (the seed for) the private key
	if (get_randomness(sk, p->seedSkByteLen) != 0) {
		// something went wrong
		fail = true;
	}

	// set up a Keccak hash instance
	Keccak_HashInstance hashInstance;
	if (Keccak_HashInitialize_SHAKE256(&hashInstance) != SUCCESS) {
		// the initialization was unsuccessful
		return -1;
	}
	if (Keccak_HashUpdate(&hashInstance, sk, p->seedSkByteLen * 8) != SUCCESS) {
		// the updating was unsuccessful
		return -1;
	}
	if (Keccak_HashFinal(&hashInstance, NULL) != SUCCESS) {
		// the finalization was unsuccessful
		return -1;
	}

	// expand the seed to generate the seed for H and include it in the public key
	if (Keccak_HashSqueeze(&hashInstance, pk, p->seedHByteLen * 8) != SUCCESS) {
		// something went wrong in the evaluation of the hash function
		return -1;
	}

	// allocate memory for H
	unsigned char** H = calloc(p->r, sizeof(unsigned char*));
	// expand the seed to obtain H
	unsigned char* temp = calloc(p->n_in_bytes * p->r, sizeof(unsigned char));
	if (SHAKE256(temp, p->n_in_bytes * p->r, pk, p->seedHByteLen) != 0) { fail = true; };
	for (int i=0; i<p->r; i++) {
		H[i] = calloc(p->n_in_bytes, sizeof(unsigned char));
		memcpy(H[i], temp+i*p->n_in_bytes, p->n_in_bytes);
		// make sure the invalid bits are zero
		H[i][(p->n_in_bytes -1)] &= (unsigned char) ((1<<(((p->n+7)%8)+1))-1); // mask the last block
	}
	free(temp);

	// generate the low-weight secret
	// this achieves a uniform distribution
	unsigned char* priv = calloc(p->n_in_bytes, sizeof(unsigned char*));
	size_t current_weight = 0;
	for (int i=0; i<p->n; i++) {
		size_t t = 0;
		if (get_rand_uint(p->n - i, &t, &hashInstance) != 0) {
			// something went wrong during the generation of the random number
			return -1;
		}
		if (t < (p->w - current_weight)) {
			// set bit to 1
			priv[i/8] = (priv[i/8] & (~(1<<(i%8)))) | (1<<(i%8));
			current_weight++;
		} else {
			// set bit to 0
			priv[i/8] = (priv[i/8] & (~(1<<(i%8))));
		}
	}

	// compute the public key
	unsigned char* pub = pk + p->seedHByteLen;
	mult_H(p, H, priv, pub);

	// clean up
	for (int i=0; i<p->r; i++) {
		free(H[i]);
	}
	free(H);
	free(priv);

	// successful execution?
	if (fail) {
		return -1;
	} else {
		return 0;
	}
}

/* -------------------------------------------------- */

// Interpretes a hash value (specified in chHash) as p->t single, ternary challenges.
// output: p->t numbers in {0,1,2}
// note: challenges needs to provide at least p->t allocated bytes
// returns 0 in case of a successful execution, -1 otherwise
int get_challenges(const Params* p, const unsigned char* chHash, unsigned char* challenges)
{
	// detect failures evaluating SHAKE
	bool fail = false;

	size_t no_bits = 0;
	size_t i = 0; // the current challenge
	size_t diglen = p->t * 2;
	unsigned char* e = (unsigned char*) calloc(diglen, sizeof(unsigned char));
	if (SHAKE256(e, diglen, chHash, p->chHashByteLen) != 0) { fail = true; };
	while (i < p->t) {
		if ((no_bits+2 + 7)/8 > diglen) {
			// we need more digest bytes
			diglen += 10;
			e = realloc(e, diglen * sizeof(unsigned char));
			if (SHAKE256(e, diglen, chHash, p->chHashByteLen) != 0) { fail = true; };
		}
		unsigned char ch = (e[no_bits/8] & (0x03<<(no_bits%8))) >> (no_bits%8);
		if (ch < 3) {
			challenges[i] = ch;
			i++;
		}
		no_bits += 2;
	}
	// free memory
	free(e);

	// successful execution?
	if (fail) {
		return -1;
	} else {
		return 0;
	}
}

/* -------------------------------------------------- */
/* Signature generation */

// This method appends the first dataBitLen bits from data to sig.
// pos is the current position in sig and is updated by this function
// returns one bit indicating if the data still fit into the signature or not
bool include_in_signature(const Params* p, unsigned char* sig, size_t* pos, const unsigned char* data, size_t dataBitLen)
{
	if (((*pos)+dataBitLen) <= (p->sigByteLen*8)) {
		// data still fits into the signature

		if (dataBitLen == 0) {
			return true;
		}

		size_t start_byte = (*pos)/8; // the byte of the signature in which we will start writing
		size_t offset = (*pos)%8; // the offset in bits (the loose bits at the end of the signature so far)
		size_t data_loose_bits = ((dataBitLen+7)%8)+1; // valid bits in the last byte of the data
		// iterate over bytes in data
		int i;
		unsigned char b;
		unsigned char mask = (1<<offset)-1;
		// all except for the last byte of the data string
		for (i=0; i<(dataBitLen+7)/8 -1; i++) {
			b = data[i];
			// add to the bytes in the signature
			sig[start_byte+i] = (sig[start_byte+i] & mask) | (b<<offset);
			sig[start_byte+i+1] = b>>(8-offset);
		}
		// handle last byte separately
		b = data[i];
		b &= (1<<data_loose_bits)-1; // mask last byte
		sig[start_byte+i] = (sig[start_byte+i] & mask) | (b<<offset);
		if (data_loose_bits+offset > 8) { // check if we need to start one more byte
			sig[start_byte+i+1] = b>>(8-offset);
		}

		(*pos) += dataBitLen;
		return true;
	} else {
		// does not fit into the signature anymore
		return false;
	}
}

// This method generates a signature on a given message.
int sign(const Params* p, const unsigned char* sk, const unsigned char* message, size_t messageByteLen, unsigned char* sig)
{
	// detect failures, e.g. generating randomness or evaluating SHAKE
	bool fail = false;

	// set up a Keccak hash instance and feed sk
	Keccak_HashInstance hashInstance;
	if (Keccak_HashInitialize_SHAKE256(&hashInstance) != SUCCESS) {
		// the initialization was unsuccessful
		return -1;
	}
	if (Keccak_HashUpdate(&hashInstance, sk, p->seedSkByteLen * 8) != SUCCESS) {
		// the updating was unsuccessful
		return -1;
	}
	if (Keccak_HashFinal(&hashInstance, NULL) != SUCCESS) {
		// the finalization was unsuccessful
		return -1;
	}

	// expand the secret seed to generate the seed for H
	unsigned char* seedH = calloc(p->seedHByteLen, sizeof(unsigned char*));
	if (Keccak_HashSqueeze(&hashInstance, seedH, p->seedHByteLen * 8) != SUCCESS) {
		// something went wrong in the evaluation of the hash function
		return -1;
	}

	// allocate memory for H
	unsigned char** H = calloc(p->r, sizeof(unsigned char*));
	// expand the seed to obtain H
	unsigned char* tempH = calloc(p->n_in_bytes * p->r, sizeof(unsigned char));
	if (SHAKE256(tempH, p->n_in_bytes * p->r, seedH, p->seedHByteLen) != 0) { fail = true; };
	for (int i=0; i<p->r; i++) {
		H[i] = calloc(p->n_in_bytes, sizeof(unsigned char));
		memcpy(H[i], tempH+i*p->n_in_bytes, p->n_in_bytes);
		// make sure the invalid bits are zero
		H[i][(p->n_in_bytes -1)] &= (unsigned char) ((1<<(((p->n+7)%8)+1))-1); // mask the last block
	}
	free(tempH);
	free(seedH);

	// recompute the low-weight secret
	unsigned char* priv = calloc(p->n_in_bytes, sizeof(unsigned char*));
	size_t current_weight = 0;
	for (int i=0; i<p->n; i++) {
		size_t t = 0;
		if (get_rand_uint(p->n - i, &t, &hashInstance) != 0) {
			// something went wrong during the generation of the random number
			return -1;
		}
		if (t < (p->w - current_weight)) {
			// set bit to 1
			priv[i/8] = (priv[i/8] & (~(1<<(i%8)))) | (1<<(i%8));
			current_weight++;
		} else {
			// set bit to 0
			priv[i/8] = (priv[i/8] & (~(1<<(i%8))));
		}
	}

	// current position in the signature, in bits
	size_t pos = 0;

	// allocate memory
	unsigned char** seedPerm = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** seedY = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** y = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** k0 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** k1 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** k2 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** com0 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** com1 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** com2 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));

	for (int i=0; i<p->t; i++) {
		seedPerm[i] = (unsigned char*) calloc(p->seedPermByteLen, sizeof(unsigned char));
		seedY[i] = (unsigned char*) calloc(p->seedYByteLen, sizeof(unsigned char));
		y[i] = (unsigned char*) calloc(p->n_in_bytes, sizeof(unsigned char));
		k0[i] = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
		k1[i] = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
		k2[i] = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
		com0[i] = (unsigned char*) calloc(p->commByteLen, sizeof(unsigned char));
		com1[i] = (unsigned char*) calloc(p->commByteLen, sizeof(unsigned char));
		com2[i] = (unsigned char*) calloc(p->commByteLen, sizeof(unsigned char));
	}

	unsigned char* chHash = (unsigned char*) calloc(p->chHashByteLen, sizeof(unsigned char));

	unsigned char* challenges = (unsigned char*) calloc(p->t, sizeof(unsigned char));

	// loop: try to generate a signature (failure due to signature too large)
	bool success;
	do {
		success = true;

		// zero signature
		memset(sig, 0, p->sigByteLen);

		// generate randomness and commitments
		for (int i=0; i<p->t; i++) {
			// get random permutation
			if (get_randomness(seedPerm[i], p->seedPermByteLen) != 0) { fail = true; };
			// sample random seed and generate y from the seed
			if (get_randomness(seedY[i], p->seedYByteLen) != 0) { fail = true; };
			if (SHAKE256(y[i], p->n_in_bytes, seedY[i], p->seedYByteLen) != 0) { fail = true; };
			y[i][p->n_in_bytes-1] &= (unsigned char) ((1<<(((p->n+7)%8)+1))-1); // make sure the invalid bits are zero
			// generate random coins
			if (get_randomness(k0[i], p->coinsCommByteLen) != 0) { fail = true; };
			if (get_randomness(k1[i], p->coinsCommByteLen) != 0) { fail = true; };
			if (get_randomness(k2[i], p->coinsCommByteLen) != 0) { fail = true; };
			// commit
			// commitment 0
			unsigned char* temp = (unsigned char*) calloc(p->r_in_bytes + p->seedPermByteLen + p->coinsCommByteLen, sizeof(unsigned char));
			memcpy(temp + p->r_in_bytes, seedPerm[i], p->seedPermByteLen); // permutation
			memcpy(temp + p->r_in_bytes + p->seedPermByteLen, k0[i], p->coinsCommByteLen); // random coins
			mult_H(p, H, y[i], temp); // H*y
			if (SHAKE256(com0[i], p->commByteLen, temp, p->r_in_bytes + p->seedPermByteLen + p->coinsCommByteLen) != 0) { fail = true; };
			free(temp);
			// commitment 1
			temp = (unsigned char*) calloc(p->n_in_bytes + p->coinsCommByteLen, sizeof(unsigned char));
			memcpy(temp + p->n_in_bytes, k1[i], p->coinsCommByteLen); // random coins
			memcpy(temp, y[i], p->n_in_bytes);
			if (apply_permutation(p, seedPerm[i], temp) != 0) { fail = true; }; // perm(y)
			if (SHAKE256(com1[i], p->commByteLen, temp, p->n_in_bytes + p->coinsCommByteLen) != 0) { fail = true; };
			// commitment 2
			memcpy(temp + p->n_in_bytes, k2[i], p->coinsCommByteLen); // random coins
			add_in_F2n(p, y[i], priv, temp);
			if (apply_permutation(p, seedPerm[i], temp) != 0) { fail = true; }; // perm(y+priv)
			if (SHAKE256(com2[i], p->commByteLen, temp, p->n_in_bytes + p->coinsCommByteLen) != 0) { fail = true; };
			free(temp);
		}

		// get challenge
		unsigned char* temp = (unsigned char*) calloc(p->t * p->commByteLen * 3 + messageByteLen, sizeof(unsigned char));
		for (int i=0; i<p->t; i++) {
			memcpy(temp + i * p->commByteLen * 3, com0[i], p->commByteLen);
			memcpy(temp + i * p->commByteLen * 3 + p->commByteLen, com1[i], p->commByteLen);
			memcpy(temp + i * p->commByteLen * 3 + p->commByteLen * 2, com2[i], p->commByteLen);
		}
		memcpy(temp + p->t * p->commByteLen * 3, message, messageByteLen);
		// compute a hash of the complete challenge
		if (SHAKE256(chHash, p->chHashByteLen, temp, p->t * p->commByteLen * 3 + messageByteLen) != 0) { fail = true; };
		free(temp);
		// include this hash in the signature
		if (!include_in_signature(p, sig, &pos, chHash, p->chHashByteLen*8)) { success = false; }
		// interpret as single ternary challenges
		if (get_challenges(p, chHash, challenges) != 0) { fail = true; }; // every byte in "challenge" is a ternary challenge

		// include one commitment per round in the signature
		for (int i=0; i<p->t; i++) {
			if (challenges[i] == 0) {
				if (!include_in_signature(p, sig, &pos, com2[i], p->commByteLen*8)) { success = false; }
			} else if (challenges[i] == 1) {
				if (!include_in_signature(p, sig, &pos, com1[i], p->commByteLen*8)) { success = false; }
			} else { // challenges[i] == 2
				if (!include_in_signature(p, sig, &pos, com0[i], p->commByteLen*8)) { success = false; }
			}
		}

		// generate response and signature
		for (int i=0; i<p->t; i++) {
			//printf("%d\n", i);

			if (challenges[i] == 0) {
				// include the random coins used in two of the initial commitments
				if (!include_in_signature(p, sig, &pos, k0[i], p->coinsCommByteLen*8)) { success = false; }
				if (!include_in_signature(p, sig, &pos, k1[i], p->coinsCommByteLen*8)) { success = false; }
				// include the seed of y
				if (!include_in_signature(p, sig, &pos, seedY[i], p->seedYByteLen*8)) { success = false; }
				// include the seed of the permutation
				if (!include_in_signature(p, sig, &pos, seedPerm[i], p->seedPermByteLen*8)) { success = false; }
			} else if (challenges[i] == 1) {
				// include the random coins used in two of the initial commitments
				if (!include_in_signature(p, sig, &pos, k0[i], p->coinsCommByteLen*8)) { success = false; }
				if (!include_in_signature(p, sig, &pos, k2[i], p->coinsCommByteLen*8)) { success = false; }
				// include y+priv
				unsigned char* temp_n = (unsigned char*) calloc(p->n_in_bytes, sizeof(unsigned char));
				add_in_F2n(p, y[i], priv, temp_n); // y+priv
				if (!include_in_signature(p, sig, &pos, temp_n, p->n)) { success = false; }
				free(temp_n);
				// include the seed of the permutation
				if (!include_in_signature(p, sig, &pos, seedPerm[i], p->seedPermByteLen*8)) { success = false; }
			} else { // challenges[i] == 2
				// include the random coins used in two of the initial commitments
				if (!include_in_signature(p, sig, &pos, k1[i], p->coinsCommByteLen*8)) { success = false; }
				if (!include_in_signature(p, sig, &pos, k2[i], p->coinsCommByteLen*8)) { success = false; }
				// include perm(y)
				unsigned char* temp_n = (unsigned char*) calloc(p->n_in_bytes, sizeof(unsigned char));
				memcpy(temp_n, y[i], p->n_in_bytes * sizeof(unsigned char));
				if (apply_permutation(p, seedPerm[i], temp_n) != 0) { fail = true; }; // perm(y)
				if (!include_in_signature(p, sig, &pos, temp_n, p->n)) { success = false; }
				// include perm(priv)
				memcpy(temp_n, priv, p->n_in_bytes * sizeof(unsigned char));
				if (apply_permutation(p, seedPerm[i], temp_n) != 0) { fail = true; }; // perm(priv)
				if (!include_in_signature(p, sig, &pos, temp_n, p->n)) { success = false; }
				free(temp_n);
			}
		}

	} while (!success);

	// free memory
	for (int i=0; i<p->t; i++) {
		free(seedPerm[i]);
		free(seedY[i]);
		free(y[i]);
		free(k0[i]);
		free(k1[i]);
		free(k2[i]);
		free(com0[i]);
		free(com1[i]);
		free(com2[i]);
	}

	free(seedPerm);
	free(seedY);
	free(y);
	free(k0);
	free(k1);
	free(k2);
	free(com0);
	free(com1);
	free(com2);

	free(chHash);

	free(challenges);

	for (int i=0; i<p->r; i++) {
		free(H[i]);
	}
	free(H);

	free(priv);

	// successful execution?
	if (fail) {
		return -1;
	} else {
		return 0;
	}
}

/* -------------------------------------------------- */
/* Verification */

// This method reads dataBitLen bits from sig and writes them to data.
// returns one bit indicating whether the requested data exceeded the signature or not
bool read_from_signature(const Params* p, const unsigned char* sig, size_t* pos, unsigned char* data, size_t dataBitLen)
{
	if (((*pos)+dataBitLen) <= (p->sigByteLen*8)) {
		// still below the signature size

		if (dataBitLen == 0) {
			return true;
		}

		size_t start_byte = (*pos)/8; // the byte of the signature from which we will start reading
		size_t offset = (*pos)%8; // the offset in bits (the loose bits at the end of the signature read so far)
		size_t data_loose_bits = ((dataBitLen+7)%8)+1; // valid bits in the last byte of the data
		// iterate over bytes in data
		int i;
		unsigned char b;
		unsigned char mask = (1<<offset)-1;
		// all except for the last byte of the data string
		for (i=0; i<(dataBitLen+7)/8 -1; i++) {
			// extract one byte from the signature
			b = (sig[start_byte+i] & (~mask)) >> offset;
			b = b | (sig[start_byte+i+1]<<(8-offset));
			data[i] = b;
		}
		// handle last byte separately
		b = (sig[start_byte+i] & (~mask)) >> offset;
		if (data_loose_bits+offset > 8) { // check if we need to check one more byte from the signature (make sure the length of th signature is not exceeded)
			b = b | (sig[start_byte+i+1]<<(8-offset));
		}
		b &= (1<<data_loose_bits)-1; // mask last byte
		data[i] = b;

		(*pos) += dataBitLen;
		return true;
	} else {
		// the queried data exceeds the signature
		return false;
	}
}

// This method checks whether a signature for a given message is valid or not.
int verify(const Params* p, const unsigned char* pk, const unsigned char* message, size_t messageByteLen, const unsigned char* sig, bool* accept)
{
	*accept = true;

	// pointer to the actual public key
	const unsigned char* pub = pk + p->seedHByteLen;

	// detect failures, e.g. generating randomness or evaluating SHAKE
	bool fail = false;

	// allocate memory for H
	unsigned char** H = calloc(p->r, sizeof(unsigned char*));
	// expand the seed to obtain H
	unsigned char* tempH = calloc(p->n_in_bytes * p->r, sizeof(unsigned char));
	if (SHAKE256(tempH, p->n_in_bytes * p->r, pk, p->seedHByteLen) != 0) { fail = true; };
	for (int i=0; i<p->r; i++) {
		H[i] = calloc(p->n_in_bytes, sizeof(unsigned char));
		memcpy(H[i], tempH+i*p->n_in_bytes, p->n_in_bytes);
		// make sure the invalid bits are zero
		H[i][(p->n_in_bytes -1)] &= (unsigned char) ((1<<(((p->n+7)%8)+1))-1); // mask the last block
	}
	free(tempH);

	// current position in the signature, in bits
	size_t pos = 0;

	// allocate memory
	unsigned char** com0 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** com1 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));
	unsigned char** com2 = (unsigned char**) calloc(p->t, sizeof(unsigned char*));

	for (int i=0; i<p->t; i++) {
		com0[i] = (unsigned char*) calloc(p->commByteLen, sizeof(unsigned char));
		com1[i] = (unsigned char*) calloc(p->commByteLen, sizeof(unsigned char));
		com2[i] = (unsigned char*) calloc(p->commByteLen, sizeof(unsigned char));
	}

	unsigned char* chHash = (unsigned char*) calloc(p->chHashByteLen, sizeof(unsigned char));

	unsigned char* challenges = (unsigned char*) calloc(p->t, sizeof(unsigned char));

	// get challenge hash and interpret as single challenges
	if (!read_from_signature(p, sig, &pos, chHash, p->chHashByteLen*8)) { *accept = false; }
	if (get_challenges(p, chHash, challenges) != 0) { fail = true; }; // every byte in "challenge" is a ternary challenge

	// extract one commitment per round from the signature
	for (int i=0; i<p->t; i++) {
		if (challenges[i] == 0) {
			if (!read_from_signature(p, sig, &pos, com2[i], p->commByteLen*8)) { *accept = false; }
		} else if (challenges[i] == 1) {
			if (!read_from_signature(p, sig, &pos, com1[i], p->commByteLen*8)) { *accept = false; }
		} else { // challenges[i] == 2
			if (!read_from_signature(p, sig, &pos, com0[i], p->commByteLen*8)) { *accept = false; }
		}
	}

	// verification
	for (int i=0; (i<p->t) && (*accept); i++) {
		if (challenges[i] == 0) {
			// extract random coins from signature
			unsigned char* k0 = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
			unsigned char* k1 = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, k0, p->coinsCommByteLen*8)) { *accept = false; }
			if (!read_from_signature(p, sig, &pos, k1, p->coinsCommByteLen*8)) { *accept = false; }
			// extract seed of y from signature and compute y
			unsigned char* seedY = (unsigned char*) calloc(p->seedYByteLen, sizeof(unsigned char));
			unsigned char* y  = (unsigned char*) calloc(p->n_in_bytes, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, seedY, p->seedYByteLen*8)) { *accept = false; }
			if (SHAKE256(y, p->n_in_bytes, seedY, p->seedYByteLen) != 0) { fail = true; };
			y[p->n_in_bytes-1] &= (unsigned char) ((1<<(((p->n+7)%8)+1))-1); // make sure the invalid bits are zero
			// extract permutation seed from signature
			unsigned char* seedPerm  = (unsigned char*) calloc(p->seedPermByteLen, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, seedPerm, p->seedPermByteLen*8)) { *accept = false; }
			// recompute commitment 0
			unsigned char* temp = (unsigned char*) calloc(p->r_in_bytes + p->seedPermByteLen + p->coinsCommByteLen, sizeof(unsigned char));
			mult_H(p, H, y, temp);
			memcpy(temp + p->r_in_bytes, seedPerm, p->seedPermByteLen);
			memcpy(temp + p->r_in_bytes + p->seedPermByteLen, k0, p->coinsCommByteLen);
			if (SHAKE256(com0[i], p->commByteLen, temp, p->r_in_bytes + p->seedPermByteLen + p->coinsCommByteLen) != 0) { fail = true; };
			free(temp);
			// recompute commitment 1
			temp = (unsigned char*) calloc(p->n_in_bytes + p->coinsCommByteLen, sizeof(unsigned char));
			memcpy(temp, y, p->n_in_bytes);
			if (apply_permutation(p, seedPerm, temp) != 0) { fail = true; };
			memcpy(temp + p->n_in_bytes, k1, p->coinsCommByteLen);
			if (SHAKE256(com1[i], p->commByteLen, temp, p->n_in_bytes + p->coinsCommByteLen) != 0) { fail = true; };
			free(temp);
			// free
			free(k0);
			free(k1);
			free(seedY);
			free(y);
			free(seedPerm);
		} else if (challenges[i] == 1) {
			// extract random coins from signature
			unsigned char* k0 = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
			unsigned char* k2 = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, k0, p->coinsCommByteLen*8)) { *accept = false; }
			if (!read_from_signature(p, sig, &pos, k2, p->coinsCommByteLen*8)) { *accept = false; }
			// extract y + s from signature
			unsigned char* ys  = (unsigned char*) calloc(p->n_in_bytes, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, ys, p->n)) { *accept = false; }
			// extract permutation seed from signature
			unsigned char* seedPerm  = (unsigned char*) calloc(p->seedPermByteLen, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, seedPerm, p->seedPermByteLen*8)) { *accept = false; }
			// recompute commitment 0
			unsigned char* temp = (unsigned char*) calloc(p->r_in_bytes + p->seedPermByteLen + p->coinsCommByteLen, sizeof(unsigned char));
			unsigned char* temp2 = (unsigned char*) calloc(p->r_in_bytes, sizeof(unsigned char));
			mult_H(p, H, ys, temp2);
			add_in_F2r(p, temp2, pub, temp);
			free(temp2);
			memcpy(temp + p->r_in_bytes, seedPerm, p->seedPermByteLen);
			memcpy(temp + p->r_in_bytes + p->seedPermByteLen, k0, p->coinsCommByteLen);
			if (SHAKE256(com0[i], p->commByteLen, temp, p->r_in_bytes + p->seedPermByteLen + p->coinsCommByteLen) != 0) { fail = true; };
			free(temp);
			// recompute commitment 2
			temp = (unsigned char*) calloc(p->n_in_bytes + p->coinsCommByteLen, sizeof(unsigned char));
			memcpy(temp, ys, p->n_in_bytes);
			if (apply_permutation(p, seedPerm, temp) != 0) { fail = true; };
			memcpy(temp + p->n_in_bytes, k2, p->coinsCommByteLen);
			if (SHAKE256(com2[i], p->commByteLen, temp, p->n_in_bytes + p->coinsCommByteLen) != 0) { fail = true; };
			free(temp);
			// free
			free(k0);
			free(k2);
			free(ys);
			free(seedPerm);
		} else { // challenges[i] == 2
			// extract random coins from signature
			unsigned char* k1 = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
			unsigned char* k2 = (unsigned char*) calloc(p->coinsCommByteLen, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, k1, p->coinsCommByteLen*8)) { *accept = false; }
			if (!read_from_signature(p, sig, &pos, k2, p->coinsCommByteLen*8)) { *accept = false; }
			// extract perm(y) from signature
			unsigned char* permy  = (unsigned char*) calloc(p->n_in_bytes, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, permy, p->n)) { *accept = false; }
			// extract perm(priv) from signature
			unsigned char* permpriv  = (unsigned char*) calloc(p->n_in_bytes, sizeof(unsigned char));
			if (!read_from_signature(p, sig, &pos, permpriv, p->n)) { *accept = false; }
			// recompute commitment 1
			unsigned char* temp = (unsigned char*) calloc(p->n_in_bytes + p->coinsCommByteLen, sizeof(unsigned char));
			memcpy(temp, permy, p->n_in_bytes);
			memcpy(temp + p->n_in_bytes, k1, p->coinsCommByteLen);
			if (SHAKE256(com1[i], p->commByteLen, temp, p->n_in_bytes + p->coinsCommByteLen) != 0) { fail = true; };
			free(temp);
			// recompute commitment 2
			temp = (unsigned char*) calloc(p->n_in_bytes + p->coinsCommByteLen, sizeof(unsigned char));
			add_in_F2n(p, permy, permpriv, temp);
			memcpy(temp + p->n_in_bytes, k2, p->coinsCommByteLen);
			if (SHAKE256(com2[i], p->commByteLen, temp, p->n_in_bytes + p->coinsCommByteLen) != 0) { fail = true; };
			free(temp);
			// check Hamming weight of perm(priv) (==? p->w)
			size_t wt = 0;
			for (int j=0; j<p->n_in_bytes; j++) {
				unsigned char c = permpriv[j];
				if (j == (p->n_in_bytes -1)) {
					c &= (unsigned char) ((1<<(((p->n+7)%8)+1))-1); // mask the last block
				}
				wt += Hamming_weight[c];
			}
			if (wt != p->w) {
				*accept = false;
			}
			// free
			free(k1);
			free(k2);
			free(permy);
			free(permpriv);
		}
	}

	// recompute the challenge hash value
	unsigned char* chHash_recomputed = (unsigned char*) calloc(p->chHashByteLen, sizeof(unsigned char));
	unsigned char* temp = (unsigned char*) calloc(p->t * p->commByteLen * 3 + messageByteLen, sizeof(unsigned char));
	for (int i=0; i<p->t; i++) {
		memcpy(temp + i * p->commByteLen * 3, com0[i], p->commByteLen);
		memcpy(temp + i * p->commByteLen * 3 + p->commByteLen, com1[i], p->commByteLen);
		memcpy(temp + i * p->commByteLen * 3 + p->commByteLen * 2, com2[i], p->commByteLen);
	}
	memcpy(temp + p->t * p->commByteLen * 3, message, messageByteLen);
	if (SHAKE256(chHash_recomputed, p->chHashByteLen, temp, p->t * p->commByteLen * 3 + messageByteLen) != 0) { fail = true; };
	free(temp);

	// compare the challenge hash value of the signature with the hash of the commitments
	if (memcmp(chHash, chHash_recomputed, p->chHashByteLen) != 0) {
		*accept = false;
	}
	free(chHash_recomputed);

	// check the zero padding (from the fixed-size modification)
	// check loose bits (until the start of the next byte)
	unsigned char b = 0;
	read_from_signature(p, sig, &pos, &b, (8-(pos%8))%8);
	if (b != 0) {
		*accept = false;
	}
	// check remaining full bytes
	size_t remaining_bytes = p->sigByteLen - (pos/8);
	if (remaining_bytes > 0) {
		unsigned char* zeros = (unsigned char*) calloc(remaining_bytes, sizeof(unsigned char));
		if (memcmp(zeros, sig + (pos/8), remaining_bytes) != 0) {
			*accept = false;
		}
	}

	// free memory
	for (int i=0; i<p->t; i++) {
		free(com0[i]);
		free(com1[i]);
		free(com2[i]);
	}

	free(com0);
	free(com1);
	free(com2);

	free(chHash);

	free(challenges);

	for (int i=0; i<p->r; i++) {
		free(H[i]);
	}
	free(H);

	// successful execution?
	if (fail) {
		return -1;
	} else {
		return 0;
	}
}

